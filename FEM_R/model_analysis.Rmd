---
title: "FEM Model Analysis"
output: html_notebook
---

This notebook is for debugging purposes. The current plan is to write a Make rule for running this notebook automatically at the end of a model run.

The purpose of this notebook is:
- Present the T-tests altogether in one document.
- Present all transition models in same document.
- Add visualisation for cross-validation 2 output

Do all this for both minimal models and cross-validation.

```{r setup, include=FALSE}
# Need to set up the working directory
workingDir <- "/home/luke/Documents/E_FEM_clean/E_FEM/output/"
knitr::opts_knit$set(root.dir = workingDir)

require(tidyverse)
require(reactable)
require(haven)
require(data.table)
require(reshape2)
require(ggplot2)
require(plyr)

```

```{r include=FALSE}

# Need this code block for reactable tables to be rendered properly in HTML
# Fix from here: https://www.gitmemory.com/issue/glin/reactable/43/618802061
htmltools::tagList(
  reactR::html_dependency_react(),
  reactR::html_dependency_reacttools(),
  reactable::reactable(iris)
)

# function to rename the dataframes, so we can run in an lapply()
rename_first_var <- function(testCSV, prefix) {
  testCSV[,1] <- paste0(testCSV[,1], '_', prefix)
  return(testCSV)
}

# function for shortening column names
shorten_columns <- function(testCSV) {
  testCSV <- testCSV %>%
                rename_at(vars(starts_with('fem_mean_wave')), funs(sub('fem_mean_wave', 'FEM_', .))) %>%
                rename_at(vars(starts_with('elsa_mean_wave')), funs(sub('elsa_mean_wave', 'ELSA_', .))) %>%
                rename_at(vars(starts_with('p_value_wave')), funs(sub('p_value_wave', 'P_Value_', .))) %>%
                dplyr::rename('Variable' = variable)
}

```

<!-- First, we will collect and present all the T-tests together. We will add the prefix 'min_' or 'cv_' onto the variable names so we don't get mixed up. -->

```{r include=FALSE}
# names for T-tests directory and filename stem
min <- "ELSA_minimal/T-tests/"
stem <- "minimal_all_waves_"

# Read in all the T-test csv files
min_uw <- read.csv(paste0(min, stem, "unweighted.csv"))
min_demog <- read.csv(paste0(min, stem, "demog.csv"))
min_binhlth <- read.csv(paste0(min, stem, "binhlth.csv"))
min_binecon <- read.csv(paste0(min, stem, "binecon.csv"))
min_risk <- read.csv(paste0(min, stem, "risk.csv"))

# Collect in a list to do some formatting
min_list <- list(min_uw, min_demog, min_binhlth, min_binecon, min_risk)
# Add prefix 'min_' onto every variable name for clarity
min_list <- lapply(min_list, rename_first_var, prefix='min')
# Rename columns to be more succinct
min_list <- lapply(min_list, shorten_columns)
# Replace na with 0
min_list <- lapply(min_list, function(x) { x[is.na(x)] <- 0; x} )

```

```{r include=FALSE}
# names for T-tests directory and filename stem
CV1 <- "ELSA_CV1/T-tests/"
stem <- "CV1_all_waves_"
# Read in files
cv_uw <- read.csv(paste0(CV1, stem, "unweighted.csv"))
cv_demog <- read.csv(paste0(CV1, stem, "demog.csv"))
cv_binhlth <- read.csv(paste0(CV1, stem, "binhlth.csv"))
cv_binecon <- read.csv(paste0(CV1, stem, "binecon.csv"))
cv_risk <- read.csv(paste0(CV1, stem, "risk.csv"))
# Now collect into list and rename vars and cols for clarity
cv_list <- list(cv_uw, cv_demog, cv_binhlth, cv_binecon, cv_risk)
cv_list <- lapply(cv_list, rename_first_var, prefix='CV')
cv_list <- lapply(cv_list, shorten_columns)
cv_list <- lapply(cv_list, function(x) { x[is.na(x)] <- 0; x} )
```

<!-- Both Minimal and Cross-validation T-tests are now renamed and collected into a separate list object each. We will now combine like tests together (i.e. demog with demog, binhlth with binhlth). -->

```{r include=FALSE}
# Set up vector with all p-value column names. Require these for table formatting
pValNames <- c('P_Value_3', 'P_Value_4', 'P_Value_5', 'P_Value_6', 'P_Value_7', 'P_Value_8')
```

<!-- Lets build the combined tables now. -->

```{r include=FALSE}
# Row bind to collect both dfs together
uw <- rbind(min_list[[1]], cv_list[[1]])
# Reorder rows in alphabetical order. This ensures that like variables are clumped together
uw <- arrange(uw, Variable)

# demog
demog <- rbind(min_list[[2]], cv_list[[2]])
demog <- arrange(demog, Variable)

# binhlth
binhlth <- rbind(min_list[[3]], cv_list[[3]])
binhlth <- arrange(binhlth, Variable)

# binecon
binecon <- rbind(min_list[[4]], cv_list[[4]])
binecon <- arrange(binecon, Variable)

# risk
risk <- rbind(min_list[[5]], cv_list[[5]])
risk <- arrange(risk, Variable)
```


# Reactable Tables

The [reactable](https://glin.github.io/reactable/index.html) package has the ability to include lots of complex styling, such as additional colour, formatting and even inline graphs built dynamically from the input data.

For the purpose of this document, we are going to include a sticky first column (so we can always see the variable names whilst scrolling), a colour gradient from white to green based on the P Value (low = white, high = green), and a red cell background for any P values of 0.

```{r echo = FALSE}
## This block will define the logic for creating the tables with Reactable
# The tables are formatted exaclty the same for each group of vars so makes sense to define this only once

# createTTT - create T-Test Table
# Have a default column definition, to handle the basic formatting, then specific formatting for the first column (Variable) and P Val cols
createTTT <- function(t) {
  # To enable a 'sticky' first column, that always shows as you scroll across the table
  stickyStyle <- list(position = "sticky", left = 0, background = "#fff", zIndex = 1,
                      borderRight = "1px solid #eee")
  
  # Define a colour ramp to use for P Value cell gradients
  greenPal <- function(x) rgb(colorRamp(c("#ffffff", "#008000"))(x), maxColorValue = 255)
  
  # Add in the green colour gradient for P Value cells. Also add a red block for value of 0
  pValColDef <- colDef(
    style = function(value) {
      color <- greenPal(value)
      if (value == 0) {
        color <- "#ff4c4c"
      }
      list(background = color)
    },
    minWidth = 110
  )
  
  pValColDef2 <- colDef(
    style = function(value) {
      if (value >= 0.05) {
        color <- "#4ca64c"
      }
      if (value < 0.05) {
        color <- "#ff6666"
      }
      list(background = color)
    },
    minWidth = 110
  )
  
  res <- reactable(t,
            defaultColDef = colDef(
              header = function(value) gsub('_', ' ', value, fixed=TRUE),
              cell = function(value) format(value, nsmall = 2),
              align = 'center'
            ),
            columns = list(
              Variable = colDef(
                  minWidth = 160,
                  style = stickyStyle,
                  headerStyle = stickyStyle),
              P_Value_1 = pValColDef2,
              P_Value_2 = pValColDef2,
              P_Value_3 = pValColDef2,
              P_Value_4 = pValColDef2,
              P_Value_5 = pValColDef2,
              P_Value_6 = pValColDef2,
              P_Value_7 = pValColDef2,
              P_Value_8 = pValColDef2
            ),
            bordered = TRUE,
            highlight = TRUE,
            striped = TRUE)
  
  return(res)
}

```

### Unweighted (Died)

```{r echo = FALSE}
# Create the actual table!
uwTab <- createTTT(uw)
uwTab
```

### Demographics

```{r echo = FALSE}
# Create the actual table!
demogTab <- createTTT(demog)
demogTab
```

### Binary Health
```{r echo = FALSE}
# Create the actual table!
binhlthTab <- createTTT(binhlth)
binhlthTab
```
### Binary Economic
```{r echo = FALSE}
# Create the actual table!
bineconTab <- createTTT(binecon)
bineconTab
```
### Risk Behaviours
```{r echo = FALSE}
# Create the actual table!
riskTab <- createTTT(risk)
riskTab
```

# Cross Validation 2 - 'Handover' plots (Still WIP need fixing)

```{r echo = FALSE}
vis_CV2_prev <- function(long, CV2) {
  
  # Keep only waves 1 - 4
  longC <- subset(long, wave < 5)
  longC <- as.data.table(longC)
  
  # Replace all NA with 0
  longC[is.na(longC)] <- 0
  
  # Have to drop r*clust vars as they contain strings
  longC <- select(longC, -contains('clust'))
  
  # Now get the weighted mean by wave of every column based on cwtresp
  l2 <- longC[ , lapply(.SD,weighted.mean,w=cwtresp), by = list(wave)]
  
  # ELSA_long is now processed to the point where we can start extracting and combining variables
  # Better start by adding year to l2 and reordering the columns
  l2$year <- seq(from=2002, to = 2008, by = 2)
  setcolorder(l2, c('year', 'wave'))
  
  # Now lets extract chronic disease variables from both dataframes and do a row combine
  # Start with cancre, diabe, hearte
  cd_l2 <- select(l2, c(year, age, cancre, diabe, hearte, lunge, smoken, bmi, employed, anyadl)) #, anyiadl, adl1, adl2, adl3p))
  cd_CV2 <- select(CV2, c(year, a_age_all, p_cancre_all, p_diabe_all, 
                            p_hearte_all, p_lunge_all, p_smoken_all, 
                            a_bmi_all, p_employed_all,  p_anyadl_all))
                            #, p_anyiadl_all p_adl1_all, p_adl2_all, p_adl3p_all))
  
  CV2_rename <- cd_CV2 %>% dplyr::rename('age' = a_age_all,
                                        'cancre' = p_cancre_all, 
                                        'diabe' = p_diabe_all, 
                                        'hearte' = p_hearte_all,
                                        'lunge' = p_lunge_all,
                                        'smoken' = p_smoken_all,
                                        'bmi' = a_bmi_all,
                                        'employed' = p_employed_all,
                                        'anyadl' = p_anyadl_all)
                                        #'anyiadl' = p_anyiadl_all)
                                        #'adl1' = p_adl1_all,
                                        #'adl2' = p_adl2_all,
                                        #'adl3p' = p_adl3p_all)
  
  combine <- rbind(cd_l2, CV2_rename)
  
  melted <- reshape2::melt(combine, id.var = 'year', value.name = 'Prevalence')
  
  ggplot(data = melted, aes(x = year, y = Prevalence, color = variable)) +
          geom_line() +
          facet_wrap(. ~ variable, scales = "free")
          #theme(panel.spacing.x = unit(1.5, 'lines')) +
          #labs(title = 'Prevalence of Chronic Disease', x = 'Year', y = 'Prevalence')
}

# Load in whole stock pop, plus the CV2 summary output file
long <- read_dta('../input_data/ELSA_long.dta')
CV2 <- read_dta('ELSA_CV2/ELSA_CV2_summary.dta')

vis_CV2_prev(long, CV2)
```

# Intervention Scenarios

### Base Initial Prevalence of Chronic Disease

```{r echo = FALSE}
visInitBasePrev <- function(base) {
  
  cdMelted <- base %>%
                select(c('year', 'p_cancre_all', 'p_diabe_all', 'p_hearte_all')) %>%
                dplyr::rename('Cancer' = p_cancre_all, 'Diabetes' = p_diabe_all, 'Heart Disease' = p_hearte_all) %>%
                filter(year == 2012) %>%
                reshape2::melt(id.var = 'year', value.name = 'Prevalence') %>%
                subset(select = -year)
  
  ggplot(data=cdMelted, aes(x=variable, y=Prevalence)) +
          geom_bar(stat = 'identity') +
          labs(title='Initial Prevalence', x='Prevalence', y='Chronic Disease')
}

baseline <- read_dta('ELSA_Baseline/ELSA_Baseline_summary.dta')

visInitBasePrev(baseline)
```

### Baseline Projections

```{r echo = FALSE}
visProjectedBaselineCD <- function(base) {
  
  # Extract vars, rename, and melt to put it in better format for graphing with ggplot2
  cdMelted <- base %>%
                select(c('year', 'p_cancre_all', 'p_diabe_all', 'p_hearte_all')) %>%
                dplyr::rename('Cancer' = p_cancre_all, 'Diabetes' = p_diabe_all, 'Heart Disease' = p_hearte_all) %>%
                reshape2::melt(id.var='year', value.name = 'Prevalence')
  
  # Create the tiled plot of disease prevalence
  ggplot(data=cdMelted, aes(x=year, y=Prevalence)) +
            geom_line() +
            facet_grid(. ~ variable) +
            theme(panel.spacing.x = unit(1.5, 'lines')) +
            labs(title = 'Prevalence of Chronic Disease', x = 'Year', y = 'Prevalence')
}

baseline <- read_dta('ELSA_Baseline/ELSA_Baseline_summary.dta')

visProjectedBaselineCD(baseline)
```

### Survival Curve

```{r echo = FALSE}
cohort <- read_dta('ELSA_cohort/ELSA_cohort_summary.dta')

cohort$age <- (cohort$year - 2012) + 50

cohort$survival <- cohort$m_endpop_all / cohort$m_endpop_all[1]
cohort$survival_m <- cohort$m_endpop_m / cohort$m_endpop_m[1]
cohort$survival_f <- cohort$m_endpop_f / cohort$m_endpop_f[1]

# plot up survival curve
ggplot(cohort, aes(x=age, y=survival)) +
        geom_line(col='black', size=0.3) +
        labs(title='Cohort Survival: All', y='Survival', x='Age')
```

# AgeUK Almanac External Validation

'The Age UK almanac of disease profiles in later life', published in October 2015, contains information on the prevalence of major diseases, conditions, and syndromes affecting older people in England, broken down by age and sex. 

```{r echo = FALSE}

#AgeUK
male_au <- read.csv('../../Validation/AgeUK-chronDisease-MALE.csv')
female_au <- read.csv('../../Validation/AgeUK-chronDisease-FEMALE.csv')

# FEM 2014 detailed output
#FEM_2014 <- read_dta('ELSA_Baseline/detailed_output/y2014_rep1.dta')
## extract males and females
#mFEM_2014 <- FEM_2014 %>% filter(male == 1)
#fFEM_2014 <- FEM_2014 %>% filter(male == 0)

# FEM 2014 summary
#FEM <- read_dta('ELSA_Baseline/ELSA_Baseline_summary.dta')
FEM <- read_dta('ELSA_AgeUK_valid/ELSA_AgeUK_valid_summary.dta')

# Keep only year 2014 from FEM summary
FEM <- filter(FEM, year == 2014)

# Specify the age groups to extract from FEM
ages <- c('6064', '6569', '7074', '7579', '8084', '8589', '9094', '9599', '100p')
# Add m and f for male and female variables
m_ages <- paste0('m_', ages)
f_ages <- paste0('f_', ages)

# Collect the age suffixes into a vector
keep_vars <- c(m_ages, f_ages)
# Now set up the chronic diseases in a list so we can create a bigger list with all of them produced
diseases <- c('hearte', 'hibpe', 'stroke', 'diabe', 'lunge', 'cancre', 'demene', 'asthmae')

# Don't like using loops but this one was just too simple to bother with figuring out the apply version
final <- c()
ticker <- 1
# Generating the column (variable) names we want to keep in a loop
for(item in diseases) {
  for(anotherItem in keep_vars) {
    final[ticker] <- paste0('p_', item, '_', anotherItem)
    ticker <- ticker + 1
  }
}

# Keep the right vars using varnames generated in loop
FEM <- FEM %>%
          select(c('year', all_of(final)))

# Rename some vars to remove 'p_' before merging
FEM <- FEM %>%
          rename_at(vars(starts_with('p_')),
                    funs(str_replace(., 'p_', ''))) %>%
          select(!year)

pivoted.FEM <- pivot_longer(data = FEM,
                            cols = hearte_m_6064:asthmae_f_100p, 
                            names_to = c('Condition', 'Gender', 'Age_Group'), 
                            names_sep = '_')

# Convert value from fraction to percentage
pivoted.FEM$value <- pivoted.FEM$value * 100

# Rename cols to enable reshaping
male_au <- male_au %>%
                dplyr::rename(m_6064 = X60.64, m_6569 = X65.69, m_7074 = X70.74, 
                       m_7579 = X75.79, m_8084 = X80.84, m_8589 = X85.89, 
                       m_9094 = X90.94, m_9599 = X95.99, m_100p = Over.100) %>%
                select(!Total)

female_au <- female_au %>%
                dplyr::rename(f_6064 = X60.64, f_6569 = X65.69, f_7074 = X70.74, 
                       f_7579 = X75.79, f_8084 = X80.84, f_8589 = X85.89, 
                       f_9094 = X90.94, f_9599 = X95.99, f_100p = Over.100) %>%
                select(!Total)

# Now need to reshape these datasets to long format
pivoted.male <- pivot_longer(data = male_au,
                             cols = m_6064:m_100p,
                             names_to = c('Gender', 'Age_Group'),
                             names_sep = '_')

pivoted.female <- pivot_longer(data = female_au,
                             cols = f_6064:f_100p,
                             names_to = c('Gender', 'Age_Group'),
                             names_sep = '_')

# Now row bind these frames together, combining male and female data
ageUK <-rbind(pivoted.male, pivoted.female)

# Now need to deal with the fact that ageUK data splits heart issues into 3 different conditions
# extract all heart related conditions for combining
ageUK_heart <- filter(ageUK, Condition == c('Coronary Heart Disease', 'Heart Failure', 'Atrial Fibrillation'))
# Aggregate the values by gender and age group
ageUK_heart <- aggregate(ageUK_heart$value, by = list(ageUK_heart$Gender, ageUK_heart$Age_Group), FUN = sum)
# Rename columns and add condition column back
colnames(ageUK_heart) <- c('Gender', 'Age_Group', 'value')
ageUK_heart$Condition <- 'Heart Problems'

# Now drop the heart problems from original ageUK and replace with aggregate
ageUK <- filter(ageUK, Condition != 'Coronary Heart Disease', Condition != 'Heart Failure', Condition != 'Atrial Fibrillation')
ageUK <- rbind(ageUK, ageUK_heart)

# Rename a few just for completeness
ageUK$Condition <- gsub("Cancer, recent", "Cancer", ageUK$Condition)
ageUK$Condition <- gsub("COPD", "Lung Disease (COPD)", ageUK$Condition)

# Finally, add column to specify that this is ageUK data
ageUK$source <- "ageUK"

# REMOVE CONDITIONS FROM ageUK THAT ARE NOT IN FEM (may change in future)
#ageUK <- filter(ageUK, Condition != c('Asthma', 'Depression', 'Severe Mental Health Condition'))
ageUK <- filter(ageUK, Condition != 'Depression', Condition != 'Severe Mental Health Conditions')

# Make copy
newFEM <- pivoted.FEM

# Rename all the conditions to fit ageUK
# NOTE: Lung disease is not a perfect match, as ageUK only contains info on COPD
#       Therefore only validation from this will be that FEM is higher than ageUK
newFEM$Condition <- gsub("hearte", "Heart Problems", newFEM$Condition)
newFEM$Condition <- gsub("hibpe", "Hypertension", newFEM$Condition)
newFEM$Condition <- gsub("stroke", "Stroke", newFEM$Condition)
newFEM$Condition <- gsub("diabe", "Diabetes", newFEM$Condition)
newFEM$Condition <- gsub("lunge", "Lung Disease (COPD)", newFEM$Condition)
newFEM$Condition <- gsub("cancre", "Cancer", newFEM$Condition)
newFEM$Condition <- gsub("demene", "Dementia", newFEM$Condition)
newFEM$Condition <- gsub("asthmae", "Asthma", newFEM$Condition)

# Add column to specify this is FEM data
newFEM$source <- "FEM"

# Now row bind the datasets
combined <- rbind(newFEM, ageUK)
# Specify factor levels for age group
combined$Age_Group <- factor(combined$Age_Group, levels = c('6064', '6569', '7074', '7579', '8084', '8589', '9094', '9599', '100p'))
# Sort
combined <- arrange(combined, source, Condition, Gender, Age_Group)

# Function to filter the combined dataset and visualise
visAgeUKValid <- function(data, cd, gender, path = '/home/luke/Documents/E_FEM_clean/Deliverables/E-FEM_Paper/figures/Validation/ageUK/') {
  
  if(gender == 'm') {
    full_gender <- 'Male'
  }
  else if(gender == 'f') {
    full_gender <- 'Female'
  }
  
  # filter by gender and condition
  data <- data %>%
            filter(Gender == gender) %>%
            filter(Condition == cd)
  
  # now plot!
  p <- ggplot(data = data, aes(x = Age_Group, y = value)) +
          geom_bar(aes(fill = source), stat = "identity", position = "dodge") +
          labs(title = paste(cd, full_gender, sep = ' '), x = 'Age Group', y = 'Proportion')
  
  # Save plot into in E-FEM_Paper/figures/
  ggsave(filename = paste0(cd, '_', gender, '.png'),
         plot = p,
         path = path,
         width = 6,
         height = 4)
  
  return(p)
}

```

```{r}
# Collect all conditions (and both genders) into a list, and apply the function above to that list
cd_list <- unique(combined$Condition)
gender_list <- unique(combined$Gender)

for(cd in cd_list) {
  for(gen in gender_list) {
    plot <- visAgeUKValid(combined, cd, gen)
    print(plot)
  }
}
```




# Github Reporting

It would be nice if we could copy paste tables directly from this document into a github issue. For this reason, we will look into a package that can print tables directly into markdown or something similar, which we can then place straight into a Github issue.

```{r}

#kable


```


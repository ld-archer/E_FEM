---
title: "R Notebook"
output: html_notebook
---


```{r "setup", include=FALSE}

# Data manipulation and visualisation
require(tidyverse)
require(ggplot2)

# Handling Stata data files
require(haven)
require(foreign)

# for multiple imputation replacement
require(mice)

# for hotdecking
require(VIM)

workingDir <- "/home/luke/Documents/E_FEM_clean/E_FEM/"
knitr::opts_knit$set(root.dir = workingDir)

rm(workingDir)
```

# Replacement Counterfactual

```{r}
## Read in ELSA_repl.dta file for replacement
repl <- read_dta('input_data/ELSA_repl.dta')
```


In this counterfactual, we will be using wealth as an input to health without directly using wealth. We want to replace the health and risk behaviour status distribution of the poorest quintile with that of the median or higher quintile to assess how differently the health outcomes would be.

Practically, I think we need to have a few different versions of this to see the impact we can create. 

1. Just risk behaviours. 
  - Drinking, smoking, BMI, exercise status, more?
2. Risk behaviours and disability
3. Risk behaviours, disability, and health status

NEED TO REMEMBER ACCOUNTING!! If changing smoking status especially, need to make sure that the smoke_start and smoke_stop variables both make sense after changes.

## Ideas

### IPF

One way to go about this is IPF, so lets figure out what we need for IPF.

- Seed
  - Just the variables of interest organised into a matrix of rows = length(people) & cols = length(variables)
- Constraints
  - Totals of each variable by age and sex

IPF actually could be a bit tricky, as I would need to collapse my seed down to counts by group, and would then need to integerise the population after this happens. I could do this using the algorithm from humanleague that is built for this purpose. Could even do the whole thing using humanleague functions? I know they are efficient and it would be nice to cite them. However this is an added layer of complexity which I could probably do to stay away from. 

### Multiple imputation

This is not a bad idea, because I can run a multiple imputation by age and sex just like I can do IPF. The `mice` package in R looks the best, and we can do different imputation methods for different variables (i.e. different methods for BMI - continuous, drinking & smoking - ordered).

```{r}
# Set up lists of id vars, demographic vars (for imputation) and risk vars to be imputed
id.var <- 'idauniq'
demog.vars <- c('wealth_quint', 'age', 'male')
risk.vars <- c('smokev', 'l2smokev', 'smoken', 'l2smoken', 'heavy_smoker',
               'l2heavy_smoker', 'drink', 'l2drink', 'problem_drinker',
               'l2problem_drinker', 'logbmi', 'l2logbmi', 'exstat',
               'l2exstat')


test <- repl %>% filter(year == 2012, wealth_quint %in% c(1, 3)) %>%
                  select(all_of(id.var), all_of(demog.vars), all_of(risk.vars))

# separate test df by quintile so we can remove data for quint1
test.1 <- test %>% filter(wealth_quint == 1)
test.3 <- test %>% filter(wealth_quint == 3)
test.1[risk.vars] <- NA
test <- rbind(test.1, test.3)

# Run mi & get a complete version of the imputed dataset
imp <- mice(data=test, m=5, maxit=10, printFlag = FALSE)
test2 <- complete(imp)

### ACCOUNTING
# if smoken == 1 then most likely l2smoken == 1 also
test2$l2smoken[is.na(test2$l2smoken)] <- test2$smoken

# if l2smokev == 1 then smokev must also == 1
test2$smokev[is.na(test2$smokev)] <- test2$l2smokev
# also, if l2smoken == 1 then l2smokev must also equal 1
test2$l2smokev[test2$l2smoken == 1] <- 1
# same for smoken
test2$l2smoken[test2$smoken == 1] <- 1

# no variability in problem_drinker -> l2problem_drinker in median wealth group,
# so assume same here
test2$l2problem_drinker[is.na(test2$l2problem_drinker)] <- test2$problem_drinker

## OK!
## The test2 dataset now contains fully imputed data for quintile 1 based on
## values from quintile 3 so far. Can easily turn this into a function and 
## use different quintiles (or just do them without the function)

rm(imp, test, test.1, test.3)
```

```{r}
## Next step is to replace the values from the original repl dataset and save 
# this as an alternative for running through the model

# copy this so we don't mess with the original repl
repl.replaced <- repl %>% filter(wealth_quint == 1) %>%
                          select(-all_of(risk.vars), -all_of(demog.vars))

# get just the quint 1 people
quint1.replaced <- test2 %>% filter(wealth_quint == 1)

# merge the modified repl with the newly replaced quint1 people
repl.replaced <- merge(repl.replaced, quint1.replaced, by='idauniq', all.x = TRUE)

# Now filter all the quint1 people from original repl and row bind the new people
repl2 <- repl %>% filter(wealth_quint != 1)

repl.final <- rbind(repl.replaced, repl2)

rm(quint1.replaced, repl.replaced, repl2)
```

Need to deal with some missing data and problems that are created by loading the data in R and saving to dta format.

Specifically, loading data in R loses the special missing characters that stata keeps and can deal with, just replaces with a simple (.) missing. One of the problem vars is educl (spouse education level), which is needed for the education imputation model. We can replace all missings with 0 as educl is used in the equation educl * married, which will be 0 if not married anyway.

```{r}

## Whatever we do in here have to do to the baseline repl as well just to make 
# sure things are standardised

repl.final2 <- repl.final
repl2 <- repl

## handle missing educl data as described above
repl.final2$educl[is.na(repl.final2$educl)] <- 0
repl2$educl[is.na(repl$educl)] <- 0

#table(repl.final2$educl)
#summary(repl.final2$educl)
#print('---------')

repl.final2$radadeduage[is.na(repl.final2$radadeduage)] <- 0
repl2$radadeduage[is.na(repl$radadeduage)] <- 0

repl.final2$ramomeduage[is.na(repl.final2$ramomeduage)] <- 0
repl2$ramomeduage[is.na(repl$ramomeduage)] <- 0

## USE THIS SPACE TO HOTDECK LOTS OF MISSING VARIABLES (start with lnly)
hotdeck.vars <- c('lnly', 'workstat', 'smokev')

repl.final2 <- hotdeck(repl.final2, variable = hotdeck.vars)
repl2 <- hotdeck(repl2, variable = hotdeck.vars)
```

```{r}
## FINALLY SAVE THE DATA
write_dta(repl.final2, 'input_data/ELSA_repl_modified_quint1.dta', version = 12)
write_dta(repl2, 'input_data/ELSA_repl_standard.dta', version = 12)
```

# Output Visualisation

## Data
```{r}

cohort <- read_dta("output/WEALTH/ELSA_cohort/ELSA_cohort_summary.dta")

```


## Survival Curve
```{r}

# Function to compare survival curves between quintiles

## THIS IS NOT USEFUL!!!
# Because we calculate survival using the m_endpop_* variable (which is a 
# population level variable) it will always give the same value for every
# subgroup.
# Need to talk to Bryan about a way to analyse this within subgroup.
survivalCurveSubgroup <- function(cohort) {
  
  # Age and survival for each quintile
  cohort$Age <- (cohort$year - 2012) + 50
  cohort$q1 <- cohort$m_endpop_wq1 / cohort$m_endpop_wq1[1]
  cohort$q2 <- cohort$m_endpop_wq2 / cohort$m_endpop_wq2[1]
  cohort$q3 <- cohort$m_endpop_wq3 / cohort$m_endpop_wq3[1]
  cohort$q4 <- cohort$m_endpop_wq4 / cohort$m_endpop_wq4[1]
  cohort$q5 <- cohort$m_endpop_wq5 / cohort$m_endpop_wq5[1]
  
  # Cut dataframe down to just the age and survivals
  survivals <- cohort %>% select(Age, q1, q2, q3, q4, q5)
  
  # pivot the data to long format for ggplot
  survivals <- pivot_longer(data = survivals,
                            cols = q1:q5,
                            names_to = "Quintile",
                            values_to = "Survival")
  
  p <- ggplot(data = survivals, mapping = aes(x = Age, y = Survival, color = Quintile)) +
    geom_smooth(se = FALSE, linetype = 'solid', size=0.4)
  
  return(p)
  
}

survivalCurveSubgroup(cohort)

```



### Testing
```{r echo=FALSE}

check <- cohort %>% select(year, m_endpop_wq1, m_endpop_wq2, m_endpop_wq3, m_endpop_wq4, m_endpop_wq5)

check2 <- cohort %>% select(year, p_anydisease_wq1, p_anydisease_wq2, p_anydisease_wq3, p_anydisease_wq4, p_anydisease_wq5)

check3 <- cohort %>% select(year, p_disabled_wq1, p_disabled_wq2, p_disabled_wq3, p_disabled_wq4, p_disabled_wq5)

```

```{r}
rm(check, check2, check3)
```


## Prevalences
```{r}

allSubgroupPrevalence <- function(cohort, var) {
  
  #Age
  cohort$Age <- (cohort$year - 2012) + 50
  
  # Build varnames
  varnames <- c()
  for (i in 1:5) {
    varnames[i] <- paste0('p_', var, '_wq', i)
  }
  
  # Select just the things we want
  prev.all <- cohort %>% select(Age, all_of(varnames))
  
  
  # # pivot the data to long format for ggplot
  survivals <- pivot_longer(data = prev.all,
                            cols = varnames[1]:varnames[5],
                            names_to = "Quintile",
                            values_to = "Disease_Prev")
  
  # plot with geom_smooth
  p <- ggplot(data = survivals, mapping = aes(x = Age, y = Disease_Prev, color = Quintile)) +
    geom_smooth(se=FALSE, size=0.4)
  
  return(p)
  
}

allSubgroupPrevalence(cohort, 'anydisease')
allSubgroupPrevalence(cohort, 'disabled')
allSubgroupPrevalence(cohort, 'severeCondition')
allSubgroupPrevalence(cohort, 'mildCondition')

```

```{r}

someSubgroupPrevalence <- function(cohort, var, subgroups) {
  
  #Age
  cohort$Age <- (cohort$year - 2012) + 50
  
  # Build varnames
  varnames <- c()
  ticker <- 1
  for (i in subgroups) {
    varnames[ticker] <- paste0('p_', var, '_wq', i)
    ticker <- ticker + 1
  }
  
  # Select just the things we want
  #prev.all <- cohort %>% select(Age, p_anydisease_wq1, p_anydisease_wq2, p_anydisease_wq3, p_anydisease_wq4, p_anydisease_wq5)
  prev.all <- cohort %>% select(Age, all_of(varnames))
  
  
  # # pivot the data to long format for ggplot
  # survivals <- pivot_longer(data = prev.all,
  #                           cols = p_anydisease_wq1:p_anydisease_wq5,
  #                           names_to = "Quintile",
  #                           values_to = "Disease_Prev")
  
  survivals <- pivot_longer(data = prev.all,
                            cols = varnames[1]:varnames[length(varnames)],
                            names_to = "Quintile",
                            values_to = "Disease_Prev")
  
  p <- ggplot(data = survivals, mapping = aes(x = Age, y = Disease_Prev, color = Quintile)) +
    geom_smooth(se=FALSE, size=0.4)
  
  return(p)
  
}

someSubgroupPrevalence(cohort, 'anydisease', subgroups = c(1,3))
someSubgroupPrevalence(cohort, 'disabled', subgroups = c(1,3))
someSubgroupPrevalence(cohort, 'disabled', subgroups = c(1,4,5))

```












